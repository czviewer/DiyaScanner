// Firebase Modular SDK v10+ imports
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.0.0/firebase-app.js';
import {
    getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged,
    createUserWithEmailAndPassword, deleteUser,
    RecaptchaVerifier, signInWithPhoneNumber,
    setPersistence, browserLocalPersistence
} from 'https://www.gstatic.com/firebasejs/10.0.0/firebase-auth.js';
import { getDatabase, ref, get, set, update } from 'https://www.gstatic.com/firebasejs/10.0.0/firebase-database.js';

// Firebase configuration (replace with your actual config if different)
const firebaseConfig = {
    apiKey: "AIzaSyBU3K7gRzqiqQt3o9thoEpd06ReLGVmm_w",
    authDomain: "diya-hero.firebaseapp.com",
    databaseURL: "https://diya-hero-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "diya-hero",
    storageBucket: "diya-hero.firebasestorage.app",
    messagingSenderId: "455829653263",
    appId: "1:455829653263:web:5a31c65bdab2b9cee0607a",
    measurementId: "G-DZYHPLQD3F"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

// --- Global State Variables ---
let currentUserData = null; // Stores the fetched user profile data from Realtime DB
let confirmationResult = null; // Used for Phone Auth OTP verification
let phoneNumberToVerify = ''; // Stores phone number for OTP flow
const OTP_COOLDOWN_SECONDS = 120; // 2 minutes for OTP resend
let otpCountdownInterval = null;
let recaptchaVerifierInstance = null;
let recaptchaWidgetId = null;
let currentDeviceId = null; // Stores the unique device ID for device binding

// Flags for controlling onAuthStateChanged processing
let isProcessingAuthState = false; // Prevents re-entry into onAuthStateChanged processing
let lastProcessedUID = null; // Tracks the UID that was last fully processed by onAuthStateChanged

// --- DOM Elements (Placeholder for the actual HTML elements in your app) ---
// These would be linked to your HTML elements. For a standalone JS file,
// they are defined as null and checked before use.
const dom = {
    authScreens: null, appScreen: null,
    loginForm: null, loginEmailInput: null, loginPasswordInput: null, loginBtn: null, loginMessage: null, showSignupBtn: null,
    phoneVerifyForm: null, last4DigitsInput: null, verifyPhoneBtn: null, phoneVerifyMessage: null, backToLoginBtn: null,
    otpForm: null, otpInput: null, verifyOtpBtn: null, otpMessage: null, resendOtpBtn: null, countdownTimer: null, recaptchaContainer: null,
    signupForm: null, signupNameInput: null, signupEmailInput: null, signupPasswordInput: null, signupEmployeeIdInput: null, signupPhoneInput: null, signupBtn: null, signupMessage: null, showLoginBtn: null,
    logoutBtn: null, userDisplayName: null, locationStatusDiv: null, locationMessageSpan: null, attendanceSection: null,
    morningCheck: null, anEnters: null, anLeaves: null, anNone: null, refreshLocationBtn: null, submitAttendanceBtn: null, attendanceMessage: null,
    messageModalOverlay: null, modalTitle: null, modalMessage: null, modalCloseBtn: null, modalOkBtn: null
};

// Attendance record to keep track of current state and locked fields (assuming this is used elsewhere)
let attendanceRecord = {
    morning: false,
    afternoon: 'None',
    late: false,
    leave: 0,
    morningLocked: false,
    anLocked: false
};

// Function to safely get DOM elements (to avoid errors if running standalone)
function getDomElements() {
    dom.authScreens = document.getElementById('auth-screens');
    dom.appScreen = document.getElementById('app-screen');

    dom.loginForm = document.getElementById('login-form');
    dom.loginEmailInput = document.getElementById('login-email');
    dom.loginPasswordInput = document.getElementById('login-password');
    dom.loginBtn = document.getElementById('login-btn');
    dom.loginMessage = document.getElementById('login-message');
    dom.showSignupBtn = document.getElementById('show-signup-btn');

    dom.phoneVerifyForm = document.getElementById('phone-verify-form');
    dom.last4DigitsInput = document.getElementById('last-4-digits');
    dom.verifyPhoneBtn = document.getElementById('verify-phone-btn');
    dom.phoneVerifyMessage = document.getElementById('phone-verify-message');
    dom.backToLoginBtn = document.getElementById('back-to-login-btn');

    dom.otpForm = document.getElementById('otp-form');
    dom.otpInput = document.getElementById('otp-input');
    dom.verifyOtpBtn = document.getElementById('verify-otp-btn');
    dom.otpMessage = document.getElementById('otp-message');
    dom.resendOtpBtn = document.getElementById('resend-otp-btn');
    dom.countdownTimer = document.getElementById('countdown-timer');
    dom.recaptchaContainer = document.getElementById('recaptcha-container');

    dom.signupForm = document.getElementById('signup-form');
    dom.signupNameInput = document.getElementById('signup-name');
    dom.signupEmailInput = document.getElementById('signup-email');
    dom.signupPasswordInput = document.getElementById('signup-password');
    dom.signupEmployeeIdInput = document.getElementById('signup-employee-id');
    dom.signupPhoneInput = document.getElementById('signup-phone');
    dom.signupBtn = document.getElementById('signup-btn');
    dom.signupMessage = document.getElementById('signup-message');
    dom.showLoginBtn = document.getElementById('show-login-btn');

    dom.logoutBtn = document.getElementById('logout-btn');
    dom.userDisplayName = document.getElementById('user-display-name');
    dom.locationStatusDiv = document.getElementById('location-status');
    dom.locationMessageSpan = document.getElementById('location-message');
    dom.attendanceSection = document.getElementById('attendance-section');
    dom.morningCheck = document.getElementById('morning-check');
    dom.anEnters = document.getElementById('an-enters');
    dom.anLeaves = document.getElementById('an-leaves');
    dom.anNone = document.getElementById('an-none');
    dom.refreshLocationBtn = document.getElementById('refresh-location-btn');
    dom.submitAttendanceBtn = document.getElementById('submit-attendance-btn');
    dom.attendanceMessage = document.getElementById('attendance-message');

    dom.messageModalOverlay = document.getElementById('message-modal-overlay');
    dom.modalTitle = document.getElementById('modal-title');
    dom.modalMessage = document.getElementById('modal-message');
    dom.modalCloseBtn = document.querySelector('#message-modal-overlay .modal-close-btn');
    dom.modalOkBtn = document.querySelector('#message-modal-overlay .btn');
}

// Call this once the DOM is loaded
document.addEventListener('DOMContentLoaded', getDomElements);

// --- Utility Functions (Adapted for standalone JS) ---

/**
 * Generates a simple UUID for device identification.
 * @returns {string} A unique device identifier.
 */
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0,
            v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

/**
 * Asynchronously gets the device ID.
 * Uses localStorage for persistence across browser sessions.
 * @returns {Promise<string>} A promise that resolves with a unique device identifier.
 */
async function getDeviceId() {
    if (currentDeviceId) {
        return currentDeviceId;
    }
    let deviceId = localStorage.getItem('app_device_id');
    if (!deviceId) {
        deviceId = generateUUID();
        localStorage.setItem('app_device_id', deviceId);
    }
    currentDeviceId = deviceId;
    return currentDeviceId;
}

/**
 * Haversine formula to calculate distance between two lat/lng points.
 * (This function is assumed to be correctly implemented for location logic)
 */
function haversineDistance(lat1, lon1, lat2, lon2) {
    // Placeholder for actual implementation
    const R = 6371; // Radius of Earth in kilometers
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;
    return distance;
}

/**
 * Displays a custom modal message.
 * @param {string} title - The title of the modal.
 * @param {string} message - The message content.
 * @param {function} onOk - Optional callback for OK button.
 */
function showModal(title, message, onOk = null) {
    if (!dom.modalTitle || !dom.modalMessage || !dom.messageModalOverlay || !dom.modalOkBtn) {
        console.error("Modal DOM elements not found.");
        alert(`${title}: ${message}`); // Fallback for missing UI
        if (onOk) onOk();
        return;
    }
    dom.modalTitle.textContent = title;
    dom.modalMessage.textContent = message;
    dom.messageModalOverlay.classList.add('show');
    dom.modalOkBtn.onclick = () => {
        hideModal();
        if (onOk) onOk();
    };
}

/**
 * Hides the custom modal.
 */
function hideModal() {
    if (dom.messageModalOverlay) {
        dom.messageModalOverlay.classList.remove('show');
    }
}

// Modal event listeners (ensure DOM elements are available)
document.addEventListener('DOMContentLoaded', () => {
    if (dom.modalCloseBtn) dom.modalCloseBtn.addEventListener('click', hideModal);
    if (dom.modalOkBtn) dom.modalOkBtn.addEventListener('click', hideModal);
    if (dom.messageModalOverlay) {
        dom.messageModalOverlay.addEventListener('click', (event) => {
            if (event.target === dom.messageModalOverlay) {
                hideModal();
            }
        });
    }
});


/**
 * Displays a message on the login/signup screen.
 * @param {HTMLElement} messageElement - The element to display the message in.
 * @param {string} message - The message to display.
 * @param {boolean} isError - True if it's an error message, false for success.
 */
function displayAuthMessage(messageElement, message, isError) {
    if (messageElement) {
        messageElement.textContent = message;
        messageElement.className = `message-box ${isError ? 'error' : 'success'}`;
        messageElement.classList.remove('hidden');
    }
}

/**
 * Displays a message on the attendance section.
 * @param {string} message - The message to display.
 * @param {boolean} isError - True if it's an error message, false for success.
 */
function displayAttendanceMessage(message, isError) {
    if (dom.attendanceMessage) {
        dom.attendanceMessage.textContent = message;
        dom.attendanceMessage.className = `message-box ${isError ? 'error' : 'success'}`;
        dom.attendanceMessage.classList.remove('hidden');
        setTimeout(() => {
            dom.attendanceMessage.classList.add('hidden');
        }, 5000); // Hide after 5 seconds
    }
}

/**
 * Toggles between login, phone verification, OTP, and signup forms.
 * @param {string} view - 'login', 'phone-verify', 'otp', or 'signup'.
 */
function toggleAuthView(view) {
    // Hide all auth forms
    if (dom.loginForm) dom.loginForm.classList.add('hidden');
    if (dom.phoneVerifyForm) dom.phoneVerifyForm.classList.add('hidden');
    if (dom.otpForm) dom.otpForm.classList.add('hidden');
    if (dom.signupForm) dom.signupForm.classList.add('hidden');

    // Hide all auth messages
    if (dom.loginMessage) dom.loginMessage.classList.add('hidden');
    if (dom.phoneVerifyMessage) dom.phoneVerifyMessage.classList.add('hidden');
    if (dom.otpMessage) dom.otpMessage.classList.add('hidden');
    if (dom.signupMessage) dom.signupMessage.classList.add('hidden');

    // Show the requested view
    switch (view) {
        case 'login':
            if (dom.loginForm) dom.loginForm.classList.remove('hidden');
            break;
        case 'phone-verify':
            if (dom.phoneVerifyForm) dom.phoneVerifyForm.classList.remove('hidden');
            if (dom.last4DigitsInput) dom.last4DigitsInput.value = ''; // Clear previous input
            break;
        case 'otp':
            if (dom.otpForm) dom.otpForm.classList.remove('hidden');
            if (dom.otpInput) dom.otpInput.value = ''; // Clear previous input
            break;
        case 'signup':
            if (dom.signupForm) dom.signupForm.classList.remove('hidden');
            break;
        default:
            console.warn("Unknown auth view requested:", view);
            break;
    }
}

// Event listeners for toggling auth views (ensure DOM elements are available)
document.addEventListener('DOMContentLoaded', () => {
    if (dom.showSignupBtn) dom.showSignupBtn.addEventListener('click', () => toggleAuthView('signup'));
    if (dom.showLoginBtn) dom.showLoginBtn.addEventListener('click', () => toggleAuthView('login'));
    if (dom.backToLoginBtn) {
        dom.backToLoginBtn.addEventListener('click', () => {
            clearInterval(otpCountdownInterval);
            if (dom.countdownTimer) dom.countdownTimer.textContent = '';
            if (dom.resendOtpBtn) dom.resendOtpBtn.disabled = false;
            confirmationResult = null;
            phoneNumberToVerify = '';
            sessionStorage.removeItem('otpVerifiedForUID');
            if (recaptchaWidgetId !== null && typeof grecaptcha !== 'undefined') {
                grecaptcha.reset(recaptchaWidgetId);
            }
            toggleAuthView('login');
        });
    }
});


/**
 * Fetches user profile data from Realtime Database.
 * This function is designed for a single attempt fetch, as per requirements.
 * @param {string} uid - The user's UID.
 * @returns {Promise<Object|null>} User data or null if not found.
 */
async function fetchUserDataFromDB(uid) {
    console.log(`Attempting to fetch user data for UID: ${uid}`);
    const userRef = ref(db, `users/${uid}`);
    try {
        const snapshot = await get(userRef);
        if (snapshot.exists()) {
            console.log(`✅ User data fetched successfully for UID: ${uid}`);
            return snapshot.val();
        } else {
            console.warn(`❌ User data not found in DB for UID: ${uid}`);
            return null;
        }
    } catch (error) {
        console.error(`Error fetching user data from DB for UID: ${uid}:`, error);
        return null;
    }
}

/**
 * Handles the login process: email/password authentication,
 * then fetches user data from Realtime DB.
 */
async function handleLogin() {
    const email = dom.loginEmailInput?.value.trim();
    const password = dom.loginPasswordInput?.value.trim();

    if (!email || !password) {
        displayAuthMessage(dom.loginMessage, 'Please enter both email and password.', true);
        return;
    }

    try {
        // Stage 1: Authenticate with email/password
        await setPersistence(auth, browserLocalPersistence);
        const userCredential = await signInWithEmailAndPassword(auth, email, password);
        const user = userCredential.user;
        console.log("Email/Password login successful. UID:", user.uid);

        // Stage 2: Fetch user profile from Realtime DB
        const fetchedUserData = await fetchUserDataFromDB(user.uid);

        if (!fetchedUserData) {
            // User data not found in DB after successful auth. This is a critical error.
            await signOut(auth); // Force logout
            showModal('User Profile Missing', 'Your profile data could not be found in our system. Please contact Admin.', () => {
                toggleAuthView('login');
            });
            return;
        }

        // Stage 3: Validate fetched user data and device ID
        if (fetchedUserData.role !== 'employee' || !fetchedUserData.id || typeof fetchedUserData.id !== 'string' || fetchedUserData.id.trim() === "" || typeof fetchedUserData.phone !== 'string' || fetchedUserData.phone.trim() === "") {
            await signOut(auth);
            showModal('Access Denied', 'Invalid user profile or missing essential data. Please contact Admin.', () => {
                toggleAuthView('login');
            });
            return;
        }

        const currentDeviceIdentifier = await getDeviceId();
        if (fetchedUserData.deviceId && fetchedUserData.deviceId !== currentDeviceIdentifier) {
            await signOut(auth);
            showModal('Device Mismatch', '❌ Attendance is not allowed from this device. Please contact Admin.', () => {
                toggleAuthView('login');
            });
            return;
        }

        // If deviceId is not set in DB, set it now (first successful login from this device)
        if (!fetchedUserData.deviceId) {
            await update(ref(db, `users/${user.uid}`), { deviceId: currentDeviceIdentifier });
            console.log("Device ID stored for first login:", currentDeviceIdentifier);
            fetchedUserData.deviceId = currentDeviceIdentifier; // Update local copy
        }

        // Store current user data globally and in sessionStorage
        currentUserData = fetchedUserData;
        sessionStorage.setItem('currentUserData', JSON.stringify(currentUserData));
        phoneNumberToVerify = currentUserData.phone; // Set phone for OTP flow

        // Stage 4: Check OTP verification status and proceed
        const otpVerifiedForUID = sessionStorage.getItem('otpVerifiedForUID');
        if (otpVerifiedForUID === user.uid) {
            console.log("OTP already verified for this session. Proceeding to app screen.");
            showAppScreen(); // Directly show app screen
        } else {
            toggleAuthView('phone-verify'); // Go to phone verification
        }
        lastProcessedUID = user.uid; // Mark this UID as processed for this session

    } catch (error) {
        console.error('Login process error:', error);
        displayAuthMessage(dom.loginMessage, `Login failed: ${error.message}`, true);
    }
}

/**
 * Handles the phone number last 4 digits verification.
 */
async function handlePhoneVerify() {
    const last4Digits = dom.last4DigitsInput?.value.trim();

    if (!last4Digits || last4Digits.length !== 4) {
        displayAuthMessage(dom.phoneVerifyMessage, 'Please enter exactly the last 4 digits.', true);
        return;
    }

    if (phoneNumberToVerify.slice(-4) === last4Digits) {
        displayAuthMessage(dom.phoneVerifyMessage, '', false); // Clear message
        toggleAuthView('otp'); // Move to OTP form
        await sendOtp();
    } else {
        displayAuthMessage(dom.phoneVerifyMessage, 'Last 4 digits do not match. Please try again.', true);
    }
}

/**
 * Sends OTP to the registered phone number.
 */
async function sendOtp() {
    if (!phoneNumberToVerify) {
        displayAuthMessage(dom.otpMessage, 'Phone number not set for OTP. Please go back and try logging in again.', true);
        showModal('Error', 'Phone number not available for OTP. Please try logging in again.');
        return;
    }

    setResendOtpBtnState(true); // Disable resend button and start countdown

    try {
        // Initialize RecaptchaVerifier only once
        if (!recaptchaVerifierInstance && dom.recaptchaContainer && typeof grecaptcha !== 'undefined') {
            recaptchaVerifierInstance = new RecaptchaVerifier(auth, dom.recaptchaContainer, {
                'size': 'invisible',
                'callback': (response) => { /* reCAPTCHA solved, this callback is triggered. */ },
                'expired-callback': () => {
                    showModal('reCAPTCHA Expired', 'Please re-verify that you are not a robot by trying again.');
                    setResendOtpBtnState(false);
                }
            });
            await recaptchaVerifierInstance.render().then((widgetId) => {
                recaptchaWidgetId = widgetId;
            }).catch(error => {
                console.error("Error rendering reCAPTCHA:", error);
                showModal('reCAPTCHA Error', `Failed to render reCAPTCHA: ${error.message}. Please check your Firebase project settings.`);
            });
        }

        confirmationResult = await signInWithPhoneNumber(auth, phoneNumberToVerify, recaptchaVerifierInstance);
        displayAuthMessage(dom.otpMessage, 'OTP sent successfully!', false);
    } catch (error) {
        clearInterval(otpCountdownInterval);
        setResendOtpBtnState(false);
        console.error('Error sending OTP:', error);
        displayAuthMessage(dom.otpMessage, `Error sending OTP: ${error.message}`, true);
        if (recaptchaWidgetId !== null && typeof grecaptcha !== 'undefined') {
            grecaptcha.reset(recaptchaWidgetId);
        }
        showModal('OTP Send Error', `Failed to send OTP: ${error.message}. Please try again.`);
    }
}

/**
 * Manages the state of the resend OTP button and countdown timer.
 * @param {boolean} disable - True to disable and start countdown, false to enable.
 */
function setResendOtpBtnState(disable) {
    if (!dom.resendOtpBtn || !dom.countdownTimer) return;

    dom.resendOtpBtn.disabled = disable;
    if (disable) {
        let timeLeft = OTP_COOLDOWN_SECONDS;
        dom.countdownTimer.textContent = `(${timeLeft}s)`;
        if (otpCountdownInterval) {
            clearInterval(otpCountdownInterval);
        }
        otpCountdownInterval = setInterval(() => {
            timeLeft--;
            const minutes = Math.floor(timeLeft / 60);
            const seconds = timeLeft % 60;
            dom.countdownTimer.textContent = `(${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')})`;

            if (timeLeft <= 0) {
                clearInterval(otpCountdownInterval);
                dom.resendOtpBtn.disabled = false;
                dom.countdownTimer.textContent = '';
            }
        }, 1000);
    } else {
        clearInterval(otpCountdownInterval);
        dom.countdownTimer.textContent = '';
    }
}

/**
 * Handles OTP verification.
 */
async function handleOtpVerification() {
    const otp = dom.otpInput?.value.trim();

    if (!otp || otp.length !== 6) {
        displayAuthMessage(dom.otpMessage, 'Please enter the 6-digit OTP.', true);
        return;
    }

    if (!confirmationResult) {
        displayAuthMessage(dom.otpMessage, 'No OTP has been sent. Please request a new OTP.', true);
        return;
    }

    try {
        await confirmationResult.confirm(otp);
        clearInterval(otpCountdownInterval);

        if (auth.currentUser) {
            sessionStorage.setItem('otpVerifiedForUID', auth.currentUser.uid);
            // currentUserData is already populated from handleLogin, no need to re-fetch
            console.log("OTP verification successful. User data already loaded.");
            showModal('Login Successful', 'You have successfully logged in!', showAppScreen);
        } else {
            // This case should ideally not happen after successful confirmation.
            // If it does, it indicates a deeper issue.
            console.error("OTP confirmed but no current user after confirmation.");
            await signOut(auth);
            showModal('Authentication Error', 'Failed to establish user session after OTP. Please try logging in again.', () => {
                toggleAuthView('login');
            });
        }
    } catch (error) {
        console.error('OTP verification error:', error);
        displayAuthMessage(dom.otpMessage, `OTP verification failed: ${error.message}`, true);
        showModal('OTP Verification Failed', `The OTP you entered is incorrect or expired. Please try again or resend OTP.`);
    }
}

/**
 * Displays the main application screen and initiates location/attendance checks.
 */
function showAppScreen() {
    if (dom.authScreens) dom.authScreens.classList.add('hidden');
    if (dom.appScreen) dom.appScreen.classList.remove('hidden');
    if (dom.userDisplayName && currentUserData) {
        dom.userDisplayName.textContent = `${currentUserData.name} (${currentUserData.email})`;
    }
    // Assuming checkUserLocationAndAttendance and related functions are defined elsewhere
    // and handle the UI updates for the main app screen.
    if (typeof checkUserLocationAndAttendance === 'function') {
        checkUserLocationAndAttendance();
    } else {
        console.warn("checkUserLocationAndAttendance function not found. Skipping location/attendance check.");
        // Fallback or display a message indicating app is ready but features are missing
        if (dom.locationMessageSpan) dom.locationMessageSpan.textContent = 'App Ready (Location check skipped)';
        if (dom.locationStatusDiv) dom.locationStatusDiv.classList.add('verified');
        if (dom.attendanceSection) dom.attendanceSection.classList.remove('hidden');
        if (dom.submitAttendanceBtn) dom.submitAttendanceBtn.disabled = false;
    }
}

/**
 * Handles new employee signup.
 */
async function handleSignup() {
    const name = dom.signupNameInput?.value.trim();
    const email = dom.signupEmailInput?.value.trim();
    const password = dom.signupPasswordInput?.value.trim();
    const empId = dom.signupEmployeeIdInput?.value.trim();
    const phone = dom.signupPhoneInput?.value.trim();

    if (!name || !email || !password || !empId || !phone) {
        displayAuthMessage(dom.signupMessage, 'Please fill in all fields.', true);
        return;
    }

    if (password.length < 6) {
        displayAuthMessage(dom.signupMessage, 'Password should be at least 6 characters.', true);
        return;
    }

    let user = null;
    try {
        // 1. Create user in Firebase Authentication
        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
        user = userCredential.user;

        // 2. Search entire branches tree to find where empId exists
        let foundBranch = null;
        let foundSubdivision = null;

        const branchesRef = ref(db, 'branches');
        const branchesSnapshot = await get(branchesRef);
        const branchesData = branchesSnapshot.val();

        if (branchesData) {
            for (const branchName in branchesData) {
                const branch = branchesData[branchName];
                if (branch.subdivisions) {
                    for (const subdivisionName in branch.subdivisions) {
                        const subdivision = branch.subdivisions[subdivisionName];
                        // Check if employees node exists and contains the empId
                        if (subdivision.employees && subdivision.employees[empId]) {
                            foundBranch = branchName;
                            foundSubdivision = subdivisionName;
                            break;
                        }
                    }
                }
                if (foundBranch) {
                    break;
                }
            }
        }

        if (foundBranch && foundSubdivision) {
            // 3. Save user node in Realtime Database with extracted branch and subdivision
            const userRef = ref(db, `users/${user.uid}`);
            await set(userRef, {
                name: name,
                phone: phone,
                email: email,
                role: "employee",
                id: empId,
                branch: foundBranch,
                subdivision: foundSubdivision
            });

            showModal('Signup Successful', 'Your account has been created. You can now log in.', () => {
                toggleAuthView('login');
                if (dom.signupNameInput) dom.signupNameInput.value = '';
                if (dom.signupEmailInput) dom.signupEmailInput.value = '';
                if (dom.signupPasswordInput) dom.signupPasswordInput.value = '';
                if (dom.signupEmployeeIdInput) dom.signupEmployeeIdInput.value = '';
                if (dom.signupPhoneInput) dom.signupPhoneInput.value = '';
            });
            displayAuthMessage(dom.signupMessage, 'Signup successful!', false);
        } else {
            // empId not found under any branch/subdivision, delete the auth user
            if (user) {
                await deleteUser(user).catch(deleteError => console.error("Error deleting user:", deleteError));
            }
            showModal('Employee ID Not Found', 'The employee ID you entered was not found. Please contact Admin.', () => {
                displayAuthMessage(dom.signupMessage, 'Signup failed: Employee ID not found.', true);
            });
        }
    } catch (error) {
        console.error('Signup error:', error);
        if (user && error.code !== 'auth/email-already-in-use') {
            await deleteUser(user).catch(deleteError => console.error("Error deleting user:", deleteError));
        }
        displayAuthMessage(dom.signupMessage, `Signup failed: ${error.message}`, true);
    }
}

/**
 * Handles user logout.
 */
async function handleLogout() {
    try {
        await signOut(auth);
        // Clear all session and local storage related to this user
        sessionStorage.removeItem('otpVerifiedForUID');
        sessionStorage.removeItem('currentUserData');
        localStorage.removeItem('app_device_id');
        currentDeviceId = null;

        // Reset all global state variables
        currentUserData = null;
        isProcessingAuthState = false;
        lastProcessedUID = null;
        phoneNumberToVerify = '';
        confirmationResult = null;
        clearInterval(otpCountdownInterval); // Stop any active OTP countdown

        // Reset UI elements
        if (dom.countdownTimer) dom.countdownTimer.textContent = '';
        if (dom.resendOtpBtn) dom.resendOtpBtn.disabled = false;
        if (recaptchaWidgetId !== null && typeof grecaptcha !== 'undefined') {
            grecaptcha.reset(recaptchaWidgetId);
        }

        // Show login screen and hide app screen
        if (dom.authScreens) dom.authScreens.classList.remove('hidden');
        if (dom.appScreen) dom.appScreen.classList.add('hidden');
        if (dom.loginEmailInput) dom.loginEmailInput.value = '';
        if (dom.loginPasswordInput) dom.loginPasswordInput.value = '';
        displayAuthMessage(dom.loginMessage, '', false); // Clear any previous messages
        if (dom.attendanceSection) dom.attendanceSection.classList.add('hidden');
        if (dom.locationMessageSpan) dom.locationMessageSpan.textContent = 'Checking location...';
        // Reset attendance form state
        // Assuming attendanceRecord and related DOM elements exist and are managed elsewhere
        // For this example, we'll reset the global attendanceRecord object
        attendanceRecord = { morning: false, afternoon: 'None', late: false, leave: 0, morningLocked: false, anLocked: false };
        if (dom.morningCheck) dom.morningCheck.checked = false;
        if (dom.anNone) dom.anNone.checked = true;
        if (dom.submitAttendanceBtn) dom.submitAttendanceBtn.disabled = true;
        toggleAuthView('login');

    } catch (error) {
        console.error('Logout error:', error);
        showModal('Logout Error', `Failed to log out: ${error.message}`);
    }
}

/**
 * Fetches branch details from Firebase.
 * @param {string} branchName - The name of the branch.
 * @returns {Promise<Object>} A promise that resolves with branch data or null.
 */
async function getBranchDetails(branchName) {
    try {
        const branchRef = ref(db, `branches/${branchName}`);
        const snapshot = await get(branchRef);
        return snapshot.val();
    } catch (error) {
        console.error('Error fetching branch details:', error);
        return null;
    }
}

/**
 * Gets the user's current GPS location.
 * @returns {Promise<Object>} A promise that resolves with {latitude, longitude} or rejects with an error.
 */
function getUserLocation() {
    return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
            reject(new Error('Geolocation is not supported by your browser.'));
            return;
        }
        navigator.geolocation.getCurrentPosition(
            (position) => {
                resolve({
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude
                });
            },
            (error) => {
                let errorMessage = 'Unknown geolocation error.';
                switch (error.code) {
                    case error.PERMISSION_DENIED:
                        errorMessage = 'Location access denied. Please enable location services for this site.';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMessage = 'Location information is unavailable.';
                        break;
                    case error.TIMEOUT:
                        errorMessage = 'The request to get user location timed out.';
                        break;
                    case error.UNKNOWN_ERROR:
                        errorMessage = 'An unknown geolocation error occurred.';
                        break;
                }
                reject(new Error(errorMessage));
            }, {
            enableHighAccuracy: true,
            timeout: 60000,
            maximumAge: 0
        }
        );
    });
}

/**
 * Checks user's location against branch location and updates UI.
 */
async function checkUserLocationAndAttendance() {
    if (dom.locationMessageSpan) dom.locationMessageSpan.textContent = 'Checking location...';
    if (dom.locationStatusDiv) dom.locationStatusDiv.className = 'location-status-box';
    if (dom.submitAttendanceBtn) dom.submitAttendanceBtn.disabled = true;
    if (dom.attendanceSection) dom.attendanceSection.classList.add('hidden');

    if (!currentUserData || !currentUserData.id || typeof currentUserData.id !== 'string' || currentUserData.id.trim() === "") {
        showModal('Employee ID Missing', 'Your employee ID is missing or invalid. Please contact Admin. Attendance cannot be marked.', () => {
            if (dom.submitAttendanceBtn) dom.submitAttendanceBtn.disabled = true;
            if (dom.attendanceSection) dom.attendanceSection.classList.add('hidden');
        });
        if (dom.locationMessageSpan) dom.locationMessageSpan.textContent = '❌ Location Error: Employee ID missing.';
        if (dom.locationStatusDiv) dom.locationStatusDiv.classList.add('error');
        return;
    }

    try {
        const userLocation = await getUserLocation();

        if (!currentUserData.branch || typeof currentUserData.branch !== 'string' || currentUserData.branch.trim() === "") {
            showModal('Error', 'User branch information is missing or invalid. Please contact Admin.');
            if (dom.locationMessageSpan) dom.locationMessageSpan.textContent = '❌ Location Error: Missing branch info.';
            if (dom.locationStatusDiv) dom.locationStatusDiv.classList.add('error');
            return;
        }

        const branchLocation = await getBranchDetails(currentUserData.branch);

        if (!branchLocation || typeof branchLocation.lat === 'undefined' || typeof branchLocation.lng === 'undefined' || typeof branchLocation.radius === 'undefined') {
            showModal('Configuration Error', `Branch location data for "${currentUserData.branch}" is incomplete or invalid. Please contact admin.`);
            if (dom.locationMessageSpan) dom.locationMessageSpan.textContent = `❌ Location Error: Branch data incomplete for ${currentUserData.branch}.`;
            if (dom.locationStatusDiv) dom.locationStatusDiv.classList.add('error');
            return;
        }

        const distance = haversineDistance(
            userLocation.latitude, userLocation.longitude,
            branchLocation.lat, branchLocation.lng
        );

        if (distance <= branchLocation.radius) {
            if (dom.locationMessageSpan) dom.locationMessageSpan.textContent = '✅ Location Verified';
            if (dom.locationStatusDiv) dom.locationStatusDiv.classList.add('verified');
            if (dom.attendanceSection) dom.attendanceSection.classList.remove('hidden');
            if (dom.submitAttendanceBtn) dom.submitAttendanceBtn.disabled = false;
            loadTodaysAttendance();
        } else {
            if (dom.locationMessageSpan) dom.locationMessageSpan.textContent = '❌ Location Error';
            if (dom.locationStatusDiv) dom.locationStatusDiv.classList.add('error');
            showModal('Location Error', `You are ${distance.toFixed(2)} km away, which is outside the allowed ${branchLocation.radius} km radius for ${currentUserData.branch}. Attendance cannot be marked.`);
            if (dom.submitAttendanceBtn) dom.submitAttendanceBtn.disabled = true;
            if (dom.attendanceSection) dom.attendanceSection.classList.add('hidden');
        }
    } catch (error) {
        console.error('Location check error:', error);
        if (dom.locationMessageSpan) dom.locationMessageSpan.textContent = `❌ Location Error: ${error.message}`;
        if (dom.locationStatusDiv) dom.locationStatusDiv.classList.add('error');
        showModal('Location Error', `Could not get your location: ${error.message}. Please ensure location services are enabled.`);
        if (dom.submitAttendanceBtn) dom.submitAttendanceBtn.disabled = true;
        if (dom.attendanceSection) dom.attendanceSection.classList.add('hidden');
    }
}

/**
 * Loads today's attendance record for the current user.
 */
async function loadTodaysAttendance() {
    const today = new Date().toISOString().split('T')[0];
    const employeeID = currentUserData.id;
    const attendancePath = `attendance/${today}/${currentUserData.branch}/${currentUserData.subdivision || 'default'}/${employeeID}`;
    const attendanceRef = ref(db, attendancePath);

    try {
        const snapshot = await get(attendanceRef);
        const savedData = snapshot.val();

        if (savedData) {
            attendanceRecord.morning = savedData.morning || false;
            attendanceRecord.afternoon = savedData.afternoon || 'None';
            attendanceRecord.late = savedData.late || false;
            attendanceRecord.leave = savedData.leave || 0;
            attendanceRecord.morningLocked = savedData.morningLocked || false;
            attendanceRecord.anLocked = savedData.anLocked || false;

            if (dom.morningCheck) dom.morningCheck.checked = attendanceRecord.morning;
            if (dom.anEnters) dom.anEnters.checked = attendanceRecord.afternoon === 'Enters';
            if (dom.anLeaves) dom.anLeaves.checked = attendanceRecord.afternoon === 'Leaves';
            if (dom.anNone) dom.anNone.checked = attendanceRecord.afternoon === 'None';

            if (dom.morningCheck) dom.morningCheck.disabled = attendanceRecord.morningLocked;
            if (dom.anEnters) dom.anEnters.disabled = attendanceRecord.anLocked;
            if (dom.anLeaves) dom.anLeaves.disabled = attendanceRecord.anLocked;
            if (dom.anNone) dom.anNone.disabled = attendanceRecord.anLocked;

            displayAttendanceMessage('Today\'s attendance loaded.', false);
        } else {
            if (dom.morningCheck) dom.morningCheck.checked = false;
            if (dom.anNone) dom.anNone.checked = true;
            if (dom.morningCheck) dom.morningCheck.disabled = false;
            if (dom.anEnters) dom.anEnters.disabled = false;
            if (dom.anLeaves) dom.anLeaves.disabled = false;
            if (dom.anNone) dom.anNone.disabled = false;
            attendanceRecord = { morning: false, afternoon: 'None', late: false, leave: 0, morningLocked: false, anLocked: false };
            displayAttendanceMessage('No attendance record found for today. Please mark your attendance.', false);
        }
        updateFormDisablementBasedOnTime();
    } catch (error) {
        console.error('Error loading attendance:', error);
        showModal('Error', `Failed to load attendance: ${error.message}`);
    }
}

/**
 * Updates the form elements' disabled state based on current time and locked status.
 */
function updateFormDisablementBasedOnTime() {
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();

    if (dom.morningCheck && !attendanceRecord.morningLocked) {
        dom.morningCheck.disabled = (currentHour >= 12);
    }

    if (!attendanceRecord.anLocked) {
        const anRadios = [dom.anEnters, dom.anLeaves, dom.anNone];
        anRadios.forEach(radio => {
            if (radio) radio.disabled = (currentHour < 12);
        });

        if (currentHour >= 12) {
            if (dom.morningCheck && dom.anEnters && dom.morningCheck.checked && dom.anEnters.checked) {
                dom.anEnters.disabled = true;
            }
            if (dom.morningCheck && dom.anLeaves && !dom.morningCheck.checked && dom.anLeaves.checked) {
                dom.anLeaves.disabled = true;
            }
        }
    }
}

/**
 * Calculates the attendance status and leave value based on current form state and time.
 * @returns {Object} An object containing statusType ('full', 'half', 'absent', 'invalid', 'pending') and leave value.
 */
function calculateAttendanceStatus() {
    const now = new Date();
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();

    const morningChecked = dom.morningCheck ? dom.morningCheck.checked : false;
    const afternoonStatus = document.querySelector('input[name="afternoon-status"]:checked')?.value || 'None';

    let statusType = 'pending';
    let leaveValue = 0;

    const isAfter9_36AM = (currentHour > 9 || (currentHour === 9 && currentMinute >= 36));
    const isBefore3PM = (currentHour < 15);
    const isAfter7PM = (currentHour >= 19);

    attendanceRecord.late = morningChecked && isAfter9_36AM;

    if (morningChecked) {
        if (afternoonStatus === 'Leaves') {
            statusType = isBefore3PM ? 'half' : 'full';
            leaveValue = isBefore3PM ? 0.5 : 0;
        } else if (afternoonStatus === 'None') {
            if (isAfter7PM) {
                statusType = 'full';
                leaveValue = 0;
            } else {
                statusType = 'pending';
            }
        } else if (afternoonStatus === 'Enters') {
            statusType = 'invalid';
        }
    } else {
        if (afternoonStatus === 'Enters') {
            statusType = 'half';
            leaveValue = 0.5;
        } else if (afternoonStatus === 'Leaves') {
            statusType = 'invalid';
        } else if (afternoonStatus === 'None') {
            if (isAfter7PM) {
                statusType = 'absent';
                leaveValue = 1;
            } else {
                statusType = 'pending';
            }
        }
    }
    return { statusType, leaveValue };
}

/**
 * Handles the submission of attendance data.
 */
if (dom.submitAttendanceBtn) {
    dom.submitAttendanceBtn.addEventListener('click', async () => {
        if (!currentUserData || !currentUserData.id || typeof currentUserData.id !== 'string' || currentUserData.id.trim() === "") {
            showModal('Submission Error', 'Your employee ID is missing or invalid. Attendance cannot be submitted. Please contact Admin.');
            return;
        }

        const { statusType, leaveValue } = calculateAttendanceStatus();

        if (statusType === 'invalid') {
            showModal('Invalid Attendance', 'The selected attendance combination is invalid. Please review your entries.');
            return;
        }

        showModal('Confirm Attendance', 'Are you sure you want to submit your attendance for today?', async () => {
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            const timestamp = now.toISOString();

            const uid = auth.currentUser.uid;
            const branch = currentUserData.branch;
            const subdivision = currentUserData.subdivision || 'default';
            const employeeID = currentUserData.id;

            const attendanceDataToSave = {
                name: currentUserData.name,
                uid: uid,
                morning: dom.morningCheck.checked,
                afternoon: document.querySelector('input[name="afternoon-status"]:checked').value,
                late: attendanceRecord.late,
                leave: leaveValue,
                timestamp: timestamp,
                morningLocked: true,
                anLocked: true
            };

            const attendancePath = `attendance/${today}/${branch}/${subdivision}/${employeeID}`;
            const leaveLogPath = `leavelogs/${employeeID}/${today}`;

            try {
                await set(ref(db, attendancePath), attendanceDataToSave);
                await set(ref(db, leaveLogPath), leaveValue);

                displayAttendanceMessage('✅ Attendance & leave saved successfully!', false);

                attendanceRecord = { ...attendanceDataToSave };
                if (dom.morningCheck) dom.morningCheck.disabled = true;
                if (dom.anEnters) dom.anEnters.disabled = true;
                if (dom.anLeaves) dom.anLeaves.disabled = true;
                if (dom.anNone) dom.anNone.disabled = true;
                if (dom.submitAttendanceBtn) dom.submitAttendanceBtn.disabled = true;

            } catch (error) {
                console.error('Error saving attendance or leave logs:', error);
                showModal('Save Error', `Failed to save: ${error.message}`);
            }
        });
    });
}

if (dom.refreshLocationBtn) dom.refreshLocationBtn.addEventListener('click', checkUserLocationAndAttendance);
if (dom.morningCheck) dom.morningCheck.addEventListener('change', updateFormDisablementBasedOnTime);
if (dom.anEnters) dom.anEnters.addEventListener('change', updateFormDisablementBasedOnTime);
if (dom.anLeaves) dom.anLeaves.addEventListener('change', updateFormDisablementBasedOnTime);
if (dom.anNone) dom.anNone.addEventListener('change', updateFormDisablementBasedOnTime);


// --- Main Authentication State Listener (Passive Observer) ---
onAuthStateChanged(auth, async (user) => {
    console.log("🔥 onAuthStateChanged triggered. User:", user?.uid);

    // Debounce logic: Prevent re-processing the same user state multiple times
    if (isProcessingAuthState) {
        console.log("Skipping onAuthStateChanged: Already processing an auth state change.");
        return;
    }
    // If the user is the same as the last processed UID, and we have currentUserData
    // and OTP is verified, it means their session is stable and data is loaded.
    // Just ensure UI is correct.
    if (user && lastProcessedUID === user.uid && currentUserData && sessionStorage.getItem('otpVerifiedForUID') === user.uid) {
        console.log("Skipping onAuthStateChanged: User already processed and OTP verified. Ensuring app screen.");
        showAppScreen();
        return;
    }

    isProcessingAuthState = true; // Set flag to true to indicate processing is in progress

    try {
        if (user) {
            lastProcessedUID = user.uid; // Store the UID being processed

            // Attempt to load user data and OTP verification status from sessionStorage
            const storedUserDataString = sessionStorage.getItem('currentUserData');
            const otpVerifiedForUID = sessionStorage.getItem('otpVerifiedForUID');

            let parsedStoredUserData = null;
            if (storedUserDataString) {
                try {
                    parsedStoredUserData = JSON.parse(storedUserDataString);
                } catch (parseError) {
                    console.error("Error parsing sessionStorage user data:", parseError);
                    parsedStoredUserData = null; // Invalidate corrupted data
                }
            }

            // Condition to proceed to app screen:
            // 1. User is authenticated (Firebase `user` object exists)
            // 2. `currentUserData` is available in sessionStorage AND matches current UID
            // 3. OTP is marked as verified for the current UID in sessionStorage
            if (parsedStoredUserData && parsedStoredUserData.uid === user.uid && otpVerifiedForUID === user.uid) {
                currentUserData = parsedStoredUserData; // Restore global currentUserData
                console.log("Using cached user data and verified OTP from sessionStorage for UID:", user.uid);
                showAppScreen();
            } else {
                // If any of the conditions above are not met, it means:
                // - It's a fresh session (sessionStorage empty)
                // - sessionStorage data is corrupted or doesn't match current user
                // - OTP was not verified for this user in this session
                // In all these cases, we force the user back to the login screen
                // to re-initiate the full login -> data fetch -> OTP flow.
                console.log("SessionStorage data incomplete or OTP not verified. Forcing re-login to re-initiate full flow.");
                await signOut(auth); // Ensure clean auth state
                toggleAuthView('login');
                // Clear all relevant session storage and global state
                currentUserData = null;
                sessionStorage.removeItem('otpVerifiedForUID');
                sessionStorage.removeItem('currentUserData');
            }

        } else {
            // No user is signed in (user is null), reset state and show login screen
            console.log("No user authenticated. Resetting state and showing login screen.");
            if (dom.authScreens) dom.authScreens.classList.remove('hidden');
            if (dom.appScreen) dom.appScreen.classList.add('hidden');
            toggleAuthView('login');

            // Clear all session-related flags and data on logout/no user
            currentUserData = null;
            lastProcessedUID = null;
            sessionStorage.removeItem('otpVerifiedForUID');
            sessionStorage.removeItem('currentUserData');
        }
    } catch (error) {
        console.error("Unhandled error during onAuthStateChanged processing:", error);
        // Fallback for any unhandled errors during auth state processing
        await signOut(auth);
        showModal('Authentication Error', `An unexpected error occurred: ${error.message}. Please try again.`);
        // Ensure state is reset on unhandled error
        currentUserData = null;
        lastProcessedUID = null;
        sessionStorage.removeItem('otpVerifiedForUID');
        sessionStorage.removeItem('currentUserData');
        toggleAuthView('login');
    } finally {
        isProcessingAuthState = false; // Always reset this flag
    }
});

// Set up a timer to periodically update form disablement based on time
// This interval runs independently of auth state changes.
setInterval(updateFormDisablementBasedOnTime, 60000); // Check every minute

// Global onloadCallback for reCAPTCHA (if used in HTML)
// This function needs to be globally accessible for the reCAPTCHA script.
window.onloadCallback = function() {
    console.log('reCAPTCHA script loaded successfully.');
    // Any reCAPTCHA rendering for explicit size can go here if needed,
    // but for invisible reCAPTCHA, it's typically handled by RecaptchaVerifier.
};
